package io.wavebeans.lib

import kotlin.reflect.KClass
import kotlin.reflect.jvm.jvmName

/**
 * Wraps lambda function [fn] to a proper [Fn] class using generic wrapper [WrapFn]. The different between using
 * that method and creating a proper class declaration is that this implementation doesn't allow to by pass parameters
 * as [initParams] is not available inside lambda function.
 *
 * ```kotlin
 * Fn.wrap { it.doSomethingAndReturn() }
 * ```
 */
actual fun <T, R> wrap(fn: (T) -> R): Fn<T, R> {
// TODO     WaveBeansClassLoader.addClassLoader(fn::class.java.classLoader)
    return WrapFn(FnInitParameters().add(fnClazz, fn::class.jvmName))
}

/**
 * [Fn] is abstract class to launch custom functions. It allows you bypass some parameters to the function execution out
 * of declaration to runtime via using [FnInitParameters]. Each [Fn] is required to have only one (or first) constructor
 * with [FnInitParameters] as the only one parameter.
 *
 * This abstraction exists to be able to separate the declaration tier and runtime tier as there is no way to access declaration
 * tier classes and data if they are not made publicly accessible. For example, it is impossible to use variables which are
 * defined inside inner closure, hence instantiating of [Fn] as inner class is not supported either. [Fn] instance can't
 * have implicit links to outer closure.
 *
 * Mainly that requirement coming from launching the WaveBeans in distributed mode as the single [Bean] should be described
 * and then restored on specific environment which differs from local one. Though, if [Bean]s run in single thread local
 * mode only, limitations are not that strict and using data out of closures may work.
 *
 * If you don't need to specify any parameters for the function execution, you may use [Fn.wrap] method to make the instance.
 * of function out of lamda function.
 */
actual abstract class Fn<T, R> actual constructor(actual val initParams: FnInitParameters) {

    /**
     * Gets the compact representation the function as string.
     */
    actual fun asString(): String {
        val fnClazz = this::class.jvmName
        val params = initParams.params.map { "${it.key}:${it.value}" }.joinToString(";")
        return "$fnClazz|$params"
    }

    actual abstract fun apply(argument: T): R
}

/**
 * Creates the instance based on the string generated by [Fn.asString].
 */
@Suppress("UNCHECKED_CAST")
actual fun <T, R> fromString(value: String): Fn<T, R> {

    val (fnClazzStr, paramsStr) = value.split("|").take(2)
    val fnClazz = Class.forName(fnClazzStr) as Class<Fn<T, R>>
    val params = paramsStr.split(";")
        .filter { it.isNotBlank() }
        .map {
            val (k, v) = it.split(":").take(2)
            k to if (v == "null") {
                null
            } else {
                v
            }
        }
        .toMap()
    return instantiate(fnClazz.kotlin, FnInitParameters(params))
}

@Suppress("UNCHECKED_CAST")
actual fun <T, R> instantiate(clazz: KClass<out Fn<T, R>>, initParams: FnInitParameters): Fn<T, R> {
    val jClazz = clazz.java
    return jClazz.declaredConstructors
        .firstOrNull { with(it.parameterTypes) { size == 1 && get(0).isAssignableFrom(FnInitParameters::class.java) } }
        .let { it ?: jClazz.declaredConstructors.firstOrNull { c -> c.parameters.isEmpty() } }
        ?.also { it.isAccessible = true }
        ?.let { c ->
            if (c.parameters.size == 1)
                c.newInstance(initParams)
            else
                c.newInstance()
        }
        ?.let { it as Fn<T, R> }
        ?: throw IllegalStateException("$clazz has no proper constructor with ${FnInitParameters::class} as only one parameter or empty at all, " +
                "it has: ${jClazz.declaredConstructors.joinToString { it.parameterTypes.toList().toString() }}"
        )
}
/**
 * Helper [Fn] to wrap lambda functions within [Fn] instance to provide more friendly API.
 */
@Suppress("UNCHECKED_CAST")
actual class WrapFn<T, R> actual constructor(initParams: FnInitParameters) : Fn<T, R>(initParams) {

    private val fn: (T) -> R

    init {
        val clazzName = initParams[fnClazz]!!
        try {
            val clazz = WaveBeansClassLoader.classForName(clazzName)
            val constructor = clazz.declaredConstructors.first()
            constructor.isAccessible = true
            fn = constructor.newInstance() as (T) -> R
        } catch (e: IllegalArgumentException) {
            throw IllegalArgumentException(
                "Wrapping function $clazzName failed, perhaps it is implemented as inner class" +
                        " and should be wrapped manually", e
            )
        }
    }

    actual override fun apply(argument: T): R {
        return fn(argument)
    }
}