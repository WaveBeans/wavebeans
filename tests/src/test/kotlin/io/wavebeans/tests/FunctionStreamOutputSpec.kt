package io.wavebeans.tests

import assertk.assertThat
import assertk.fail
import io.wavebeans.fs.core.WbFileDriver
import io.wavebeans.lib.*
import io.wavebeans.lib.io.*
import io.wavebeans.lib.io.WriteFunctionPhase.*
import io.wavebeans.lib.stream.map
import io.wavebeans.lib.stream.times
import io.wavebeans.lib.stream.trim
import io.wavebeans.lib.stream.window.window
import io.wavebeans.metrics.MetricService
import org.spekframework.spek2.Spek
import org.spekframework.spek2.lifecycle.CachingMode.TEST
import org.spekframework.spek2.style.specification.describe
import java.io.File
import java.net.URI
import kotlin.math.abs

object FunctionStreamOutputSpec : Spek({

    val ports = createPorts(2)
    val facilitatorLocations = listOf("localhost:${ports[0]}", "localhost:${ports[1]}")

    beforeEachTest {
        MetricService.reset()
    }

    beforeGroup {
        Thread { startFacilitator(ports[0]) }.start()
        Thread { startFacilitator(ports[1]) }.start()
        waitForFacilitatorToStart("localhost:${ports[0]}")
        waitForFacilitatorToStart("localhost:${ports[1]}")
    }

    afterGroup {
        terminateFacilitator("localhost:${ports[0]}")
        terminateFacilitator("localhost:${ports[1]}")
    }

    data class Param(
            val mode: String,
            val locateFacilitators: () -> List<String>,
            val evaluate: (StreamOutput<*>, Float, List<String>) -> Unit
    )

    val modes: List<Param> = listOf(
            Param("local", { emptyList() }) { o, sampleRate, _ ->
                o.evaluate(sampleRate)
            },
            Param("multi-threaded", { emptyList() }) { o, sampleRate, _ ->
                o.evaluateInMultiThreadedMode(sampleRate)
            },
            Param("distributed", { facilitatorLocations }) { o, sampleRate, facilitators ->
                o.evaluateInDistributedMode(sampleRate, facilitators)
            },
    )

    describe("Writing encoded samples") {

        class FileEncoderFn<T : Any>(initParameters: FnInitParameters) : Fn<WriteFunctionArgument<T>, Boolean>(initParameters) {

            constructor(file: String) : this(FnInitParameters().add("file", file))

            private val file by lazy {
                WbFileDriver.createFile(URI(initParams.string("file")))
                        .createWbFileOutputStream()
            }
            private val bytesPerSample = BitDepth.BIT_32.bytesPerSample
            private val bitDepth = BitDepth.BIT_32

            override fun apply(argument: WriteFunctionArgument<T>): Boolean {
                when (argument.phase) {
                    WRITE -> {
                        when (argument.sampleClazz) {
                            Sample::class -> {
                                val element = argument.sample!! as Sample
                                val buffer = ByteArray(bytesPerSample)
                                buffer.encodeSampleLEBytes(0, element, bitDepth)
                                file.write(buffer)
                            }
                            SampleVector::class -> {
                                val element = argument.sample!! as SampleVector
                                val buffer = ByteArray(bytesPerSample * element.size)
                                for (i in element.indices) {
                                    buffer.encodeSampleLEBytes(i * bytesPerSample, element[i], bitDepth)
                                }
                                file.write(buffer)
                            }
                            else -> fail("Unsupported $argument")
                        }
                    }
                    CLOSE -> file.close()
                    END -> {
                        /*nothing to do*/
                    }
                }
                return true
            }
        }

        val input = (440.sine() * 0.2).map { it * 2 }.trim(2000)
        val sampleRate = 4000.0f
        val outputFile by memoized(TEST) { File.createTempFile("temp", ".raw") }
        val generated by memoized(TEST) {
            ByteArrayLittleEndianInput(ByteArrayLittleEndianInputParams(
                    sampleRate,
                    BitDepth.BIT_32,
                    outputFile.readBytes()
            )).toList(sampleRate)
        }

        modes.forEach { (mode, locateFacilitators, evaluate) ->
            it("should store sample bytes as LE into a file in mode $mode") {
                val o = input.out(FileEncoderFn("file://${outputFile.absolutePath}"))
                evaluate(o, sampleRate, locateFacilitators())

                assertThat(generated).isContainedBy(input.toList(sampleRate)) { a, b -> abs(a - b) < 1e-8 }
            }
            it("should store sample vector bytes as LE into a file in mode $mode") {
                val o = input
                        .window(64).map { sampleVectorOf(it) }
                        .out(FileEncoderFn("file://${outputFile.absolutePath}"))
                evaluate(o, sampleRate, locateFacilitators())

                assertThat(generated).isContainedBy(input.toList(sampleRate)) { a, b -> abs(a - b) < 1e-8 }
            }
        }
    }
})